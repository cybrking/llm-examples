import streamlit as st
import requests
from urllib.parse import urlparse
import pandas as pd
import plotly.graph_objects as go

def check_http_headers(url):
    try:
        response = requests.head(url, allow_redirects=True)
        headers = response.headers
        checks = [
            ("X-Frame-Options", headers.get("X-Frame-Options"), "Protects against clickjacking attacks"),
            ("X-XSS-Protection", headers.get("X-XSS-Protection"), "Enables browser's built-in XSS protection"),
            ("Content-Security-Policy", headers.get("Content-Security-Policy"), "Mitigates various attacks including XSS and injection attacks"),
            ("Strict-Transport-Security", headers.get("Strict-Transport-Security"), "Enforces HTTPS connections"),
            ("X-Content-Type-Options", headers.get("X-Content-Type-Options"), "Prevents MIME type sniffing"),
            ("Referrer-Policy", headers.get("Referrer-Policy"), "Controls how much referrer information should be included with requests"),
            ("Feature-Policy", headers.get("Feature-Policy"), "Allows/disallows browser features in its own frame and content within it"),
            ("Access-Control-Allow-Origin", headers.get("Access-Control-Allow-Origin"), "Specifies which domains can access the resources"),
            ("X-Permitted-Cross-Domain-Policies", headers.get("X-Permitted-Cross-Domain-Policies"), "Specifies if cross-domain policies are allowed"),
            ("Expect-CT", headers.get("Expect-CT"), "Helps detect and prevent the use of misissued SSL certificates"),
            ("Public-Key-Pins", headers.get("Public-Key-Pins"), "Prevents man-in-the-middle attacks with forged certificates"),
            ("Cache-Control", headers.get("Cache-Control"), "Specifies caching mechanisms in requests/responses"),
            ("Clear-Site-Data", headers.get("Clear-Site-Data"), "Clears browsing data associated with the requesting website"),
        ]
        return checks
    except requests.RequestException as e:
        return [("Error", str(e), "Failed to retrieve headers")]

def create_gauge_chart(score):
    fig = go.Figure(go.Indicator(
        domain = {'x': [0, 1], 'y': [0, 1]},
        value = score,
        mode = "gauge+number",
        title = {'text': "Security Score"},
        gauge = {
            'axis': {'range': [None, 100]},
            'bar': {'color': "darkblue"},
            'steps' : [
                {'range': [0, 50], 'color': "red"},
                {'range': [50, 75], 'color': "yellow"},
                {'range': [75, 100], 'color': "green"}],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': 90}}))
    return fig

def get_status_and_color(value):
    if value:
        return "Set", "#28a745"
    else:
        return "Not Set", "#dc3545"

def main():
    st.set_page_config(page_title="SecureHeaderScan", page_icon="üõ°Ô∏è", layout="wide")

    st.title("üõ°Ô∏è SecureHeaderScan")
    st.markdown("### HTTP Header Security Checker")

    st.markdown("""
    SecureHeaderScan analyzes the security headers of a given URL, helping you identify potential vulnerabilities 
    and misconfigurations in your web application's HTTP headers.
    """)

    url = st.text_input("Enter a URL to check:", placeholder="https://example.com")
    if st.button("Scan Headers", key="scan_button"):
        if url:
            with st.spinner("Analyzing HTTP headers..."):
                header_checks = check_http_headers(url)
                
                df = pd.DataFrame(header_checks, columns=["Header", "Value", "Description"])
                
                st.markdown("## HTTP Header Analysis Results")
                
                # Create a color-coded table
                table_data = []
                for _, row in df.iterrows():
                    status, color = get_status_and_color(row['Value'])
                    table_data.append({
                        "Header": row['Header'],
                        "Status": status,
                        "Color": color
                    })
                
                table_df = pd.DataFrame(table_data)
                
                st.markdown(
                    table_df.style.apply(lambda x: [f'background-color: {row.Color}' for i in x], axis=1)
                             .hide_index()
                             .to_html(),
                    unsafe_allow_html=True
                )
                
                # Expandable details
                for _, row in df.iterrows():
                    with st.expander(f"Details for {row['Header']}"):
                        st.markdown(f"**Value:** {row['Value'] if row['Value'] else 'Not Set'}")
                        st.markdown(f"**Description:** {row['Description']}")
                        if not row['Value']:
                            st.warning("This header is not set, which may pose a security risk.")
                        elif row['Header'] == "X-Frame-Options" and row['Value'].upper() not in ["DENY", "SAMEORIGIN"]:
                            st.warning("The X-Frame-Options header should be set to DENY or SAMEORIGIN for best security.")
                        elif row['Header'] == "X-XSS-Protection" and row['Value'] != "1; mode=block":
                            st.warning("For best protection against XSS attacks, set this header to '1; mode=block'.")
                        else:
                            st.success("This header is properly set.")

                st.markdown("## Overall Security Score")
                security_score = sum(1 for check in header_checks if check[1]) / len(header_checks) * 100
                fig = create_gauge_chart(security_score)
                st.plotly_chart(fig, use_container_width=True)

        else:
            st.error("Please enter a valid URL")

    st.markdown("""
    ---
    **Disclaimer:** SecureHeaderScan is for educational purposes only. 
    Always obtain explicit permission before scanning websites you do not own or operate.
    """)

if __name__ == "__main__":
    main()